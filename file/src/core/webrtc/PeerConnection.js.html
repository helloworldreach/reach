<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/core/webrtc/PeerConnection.js | Reach API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/webcom-components/reach" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Reach.js~Reach.html">Reach</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Config.js~Config.html">Config</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Invite.js~Invite.html">Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Message.js~Message.html">Message</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Participant.js~Participant.html">Participant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Room.js~Room.html">Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/User.js~User.html">User</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core/stream</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Local.js~Local.html">Local</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Remote.js~Remote.html">Remote</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core/util</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/util/Media.js~Media.html">Media</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core/webrtc</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/webrtc/PeerConnection.js~PeerConnection.html">PeerConnection</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">definitions</div><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Browser">Browser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/audio">Codec/audio</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/video">Codec/video</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Invite">Events/Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Reach">Events/Reach</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Room">Events/Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Stream">Events/Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ICEServer">ICEServer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StreamTypes">StreamTypes</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">external/datasync</div><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/Webcom.html">Webcom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/api.Query.html#~cancelCallback">Webcom/api.Query~cancelCallback</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">external/dom</div><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element">Element</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">external/webrtc</div><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://w3c.github.io/mediacapture-main/#idl-def-MediaDeviceInfo">MediaDeviceInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#stream-api">MediaStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStreamConstraints">MediaStreamConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints">MediaTrackConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#interface-definition">RTCPeerConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcrtpsender-interface">RTCRtpSender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcsessiondescription-class">RTCSessionDescription</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/core/webrtc/PeerConnection.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*global RTCPeerConnection*/
/*global RTCRtpSender*/
import cache from &apos;../util/cache&apos;;
import * as Log from &apos;../util/Log&apos;;
import Media from &apos;../util/Media&apos;;
import * as DataSync from &apos;../util/DataSync&apos;;
import {OPENED, CLOSING, CLOSED} from &apos;../util/constants&apos;;
import &apos;core-js/fn/array/find&apos;;

const DtlsSrtpKeyAgreement = {DtlsSrtpKeyAgreement: true};
const sdpConstraints = receive =&gt; ({OfferToReceiveAudio: receive, OfferToReceiveVideo: receive});
/**
 * ICE connection status : disconnected
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_DISCONNECTED = &apos;disconnected&apos;;
/**
 * ICE connection status : connected
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_CONNECTED= &apos;connected&apos;;
/**
 * ICE connection status : completed
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_COMPLETED = &apos;completed&apos;;
/**
 * ICE connection status : checking
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_CHECKING = &apos;checking&apos;;
/**
 * ICE connection status : closed
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_CLOSED = &apos;closed&apos;;
/**
 * ICE connection status : failed
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_FAILED = &apos;failed&apos;;
/**
 * ICE connection status : another status
 * @constant
 * @type {string}
 */
const ICE_CONNECTION_STATE_OTHER= &apos;other&apos;;
/**
 * @ignore
 */
const _toJSON = o =&gt; o.toJSON &amp;&amp; typeof o.toJSON === &apos;function&apos; ? o.toJSON() : o;
/**
 * The PeerConnection. A PeerConnection will only concern one MediaStream.
 * @class PeerConnection
 */
export default class PeerConnection {
	/**
	 * @access protected
	 * @param {string} stackId The WebRTC stack ID
	 * @param {string} streamId The Stream UID
	 * @param {string} remoteDevice The remote device&apos;s UID
	 * @param {boolean} publish Publish or Subscribe ?
	 */
	constructor(stackId, streamId, remoteDevice, publish) {
		/**
		 * The stack identifier. Used to identify exchanges between 2 devices
		 * @type {string}
		 */
		this.stackId = stackId;
		/**
		 * The stream id. (One stream per RTCPeerConnection)
		 * @type {string}
		 */
		this.streamId = streamId;
		/**
		 * The remote device Id
		 * @type {string}
		 */
		this.remoteDevice = remoteDevice;
		/**
		 * Path for local signalization
		 * @access private
		 * @type {string}
		 */
		this._localPath = `_/webrtc/${this.stackId}/${this.streamId}/${cache.device}`;
		/**
		 * Path for local signalization
		 * @access private
		 * @type {string}
		 */
		this._remotePath = `_/webrtc/${this.stackId}/${this.streamId}/${this.remoteDevice}`;
		/**
		 * Indicates if the PeerConnection has been established. (Useful for renegotiation).
		 * @type {boolean}
		 */
		this.negotiated = false;
		/**
		 * The DOM element where the remote MediaStream will be displayed
		 * @type {Element}
		 * @protected
		 */
		this.node = null;
		/**
		 * The DOM element containg the media element
		 * @type {Element}
		 * @protected
		 */
		this.container = null;
		/**
		 * The actual RTCPeerConnection
		 * @type {RTCPeerConnection}
		 */
		this.pc = new RTCPeerConnection(
			{
				iceServers: cache.config.iceServers
			},
			{
				optional: [DtlsSrtpKeyAgreement],
				mandatory: sdpConstraints(!publish)
			}
		);
		// Handle ICE candidates
		this.pc.onicecandidate = e =&gt; {
			if (!this.negotiated &amp;&amp; e.candidate) {
				Log.d(&apos;PeerConnection~onicecandidate&apos;, e.candidate);
				DataSync.push(`${this._localPath}/ice`, _toJSON(e.candidate));
			}
		};
		this.pc.oniceconnectionstatechange = () =&gt; {
			Log.d(&apos;PeerConnection~oniceconnectionstatechange&apos;, this.pc);
			const iceConnectionState = this.pc.iceConnectionState;
			switch (iceConnectionState) {
				case ICE_CONNECTION_STATE_CHECKING:
					// Nothing to do yet
					break;
				case ICE_CONNECTION_STATE_CONNECTED:
					this._attachStream();
					this._remoteICECandidates(false);
					break;
				case ICE_CONNECTION_STATE_COMPLETED:
					this._remoteICECandidates(false);
					break;
				case ICE_CONNECTION_STATE_DISCONNECTED:
				case ICE_CONNECTION_STATE_FAILED:
					Log.e(&apos;PeerConnection~stateDisconnected&apos;, &apos;Disconnect PeerConnection&apos;);
					break;
				case ICE_CONNECTION_STATE_CLOSED:
					Log.d(&apos;PeerConnection~stateclosed&apos;, &apos;Close PeerConnection&apos;);
					this.close();
					break;
			}
			this.negotiated = this.negotiated || this.isConnected;
		};

		this.pc.onicegatheringstatechange = () =&gt; {
			Log.d(&apos;PeerConnection~onicegatheringstatechange&apos;, this.pc.iceGatheringState);
		};

		/**
		 * PeerConnection status
		 * @type {string}
		 * @private
		 */
		this._status = OPENED;
	}

	/**
	 * Toggle ICE Candidates discovery
	 * @access private
	 * @param {boolean} listen Indicates if we should listen to new ICE candidates
	 */
	_remoteICECandidates(listen) {
		const
			path = `${this._remotePath}/ice`,
			event = &apos;child_added&apos;;
		if(listen) {
			// don&apos;t listen to ice candidates if pc is already up (renegotiation)
			DataSync.on(path, event, snap =&gt; {
				const candidate = snap.val();
				Log.d(&apos;PeerConnection~addIceCandidate&apos;, candidate);
				this.pc.addIceCandidate(new RTCIceCandidate(candidate));
			});
		} else {
			DataSync.off(path, event);
		}
	}

	/**
	 * Attach the remote MediaStream to a node
	 * @access private
	 */
	_attachStream () {
		if(this.remoteStream &amp;&amp; this.isConnected) {
			this.node = Media.attachStream(this.remoteStream, this.container, this.node);
			this.node.muted = false;
		}
	}

	/**
	 * The remote MediaStream
	 * @access protected
	 * @type {MediaStream}
	 */
	set remoteStream (stream) {
		/**
		 * @ignore
		 */
		this._remoteStream = stream;
		this._attachStream();
	}

	/**
	 * The remote MediaStream
	 * @type {MediaStream}
	 */
	get remoteStream () {
		return this._remoteStream;
	}

	/**
	 * Indicates if the PeerConnection is established based on ICE connection state
	 * @returns {boolean}
	 */
	get isConnected () {
		return this.pc &amp;&amp;
			!!~[
				ICE_CONNECTION_STATE_CONNECTED,
				ICE_CONNECTION_STATE_COMPLETED,
				ICE_CONNECTION_STATE_OTHER
			].indexOf(this.pc.iceConnectionState);
	}

	/**
	 * Init RTCPeerConnection for subscribers
	 * @access protected
	 * @param htmlElement
	 * @returns {Promise.&lt;PeerConnection&gt;}
	 */
	answer(htmlElement) {
		Log.i(&apos;PeerConnection~answer&apos;, {htmlElement, peerConnection: this});
		this.container = htmlElement;
		if(Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, &apos;ontrack&apos;)) {
			this.pc.ontrack = e =&gt; {
				Log.d(&apos;PeerConnection~ontrack&apos;, e.streams[0]);
				this.remoteStream = e.streams[0];
			};
		} else {
			this.pc.onaddstream = e =&gt; {
				Log.d(&apos;PeerConnection~onaddstream&apos;, e.stream);
				this.remoteStream = e.stream;
			};
		}

		// Listen to SDP offer
		DataSync.on(`${this._remotePath}/sdp`, &apos;value&apos;, snap =&gt; {
			const sdpOffer = snap.val();
			Log.d(&apos;Offer&apos;, sdpOffer);
			if(sdpOffer != null) {
				Log.d(&apos;PeerConnection~offered&apos;, sdpOffer);
				this.pc.setRemoteDescription(sdpOffer)
					.then(() =&gt; Log.d(&apos;PeerConnection~remoteDescription&apos;, this.pc.remoteDescription))
					.then(() =&gt; {
						if (/^offer$/.test(this.pc.remoteDescription.type)) {
							return this.pc.createAnswer();
						}
						return Promise.reject(new Error(&apos;SDP is not an offer&apos;));
					})
					.then(description =&gt; this._setPreferredCodecs(description))
					.then(description =&gt; this.pc.setLocalDescription(description))
					.then(() =&gt; {
						Log.d(&apos;PeerConnection~localDescription&apos;, this.pc.localDescription);
						this._remoteICECandidates(true);
					})
					.then(() =&gt; DataSync.update(`${this._localPath}/sdp`, _toJSON(this.pc.localDescription)))
					.catch(Log.r(&apos;PeerConnection~localDescription&apos;));
			}
		});

		return Promise.resolve(this);
	}

	/**
	 * Init RTCPeerConnection for publishers
	 * @access protected
	 * @param stream
	 * @returns {Promise.&lt;PeerConnection&gt;}
	 */
	offer(stream) {
		Log.i(&apos;PeerConnection~offer&apos;, {stream, peerConnection: this});
		let sendTimeout;
		return new Promise((resolve, reject) =&gt; {
			this.pc.onnegotiationneeded = () =&gt; {
				Log.d(&apos;PeerConnection~onnegotiationneeded&apos;);
				// Debounce send (renegotiation triggers multiple negotiationneeded events)
				if(sendTimeout) {
					clearTimeout(sendTimeout);
					sendTimeout = null;
				}
				sendTimeout = setTimeout(() =&gt; {
					sendTimeout = null;
					this._sendOffer()
						.then(() =&gt; {
							resolve(this);
						})
						.catch(e =&gt; {
							Log.d(&apos;PeerConnection~offer&apos;, e);
							reject(e);
						});
				}, 20);
			};
			DataSync.on(`${this._remotePath}/sdp`, &apos;value&apos;, snap =&gt; {
				const sdpAnswer = snap.val();
				if(sdpAnswer != null) {
					Log.d(&apos;PeerConnection~offer#answered&apos;, sdpAnswer);
					this.pc.setRemoteDescription(sdpAnswer)
						.then(() =&gt; {
							Log.d(&apos;PeerConnection~offer#remoteDescription&apos;, this.pc.remoteDescription);
							this._remoteICECandidates(true);
						})
						.catch(Log.e.bind(Log, &apos;PeerConnection~remoteDescription&apos;));
				}
			});
			this._alterStream(stream, &apos;add&apos;);
		});
	}

	/**
	 * Create SDP offer and push it
	 * @returns {Promise}
	 * @private
	 */
	_sendOffer() {
		Log.d(&apos;PeerConnection~_sendOffer&apos;);
		return this.pc.createOffer()
			.then(description =&gt; this._setPreferredCodecs(description))
			.then(description =&gt; this.pc.setLocalDescription(description))
			.then(() =&gt; Log.d(&apos;PeerConnection~renegotiate#localDescription&apos;, this.pc.localDescription))
			.then(() =&gt; DataSync.update(`${this._localPath}/sdp`, _toJSON(this.pc.localDescription)));
	}

	/**
	 * Add/Remove tracks to the PeerConnection stream
	 * @param {MediaStream} stream
	 * @param {string} method
	 * @private
	 */
	_alterStream(stream, method) {
		if(Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, `${method}Track`)) {
			if (method === &apos;add&apos;) {
				stream.getTracks().forEach(track =&gt; this.pc[`${method}Track`](track, stream), this);
			} else {
				this.pc.getSenders().forEach(sender =&gt; this.pc[`${method}Track`](sender), this);
			}
		} else {
			this.pc[`${method}Stream`](stream);
		}
	}

	/**
	 * Restart SDP negotiation following a MediaStream change
	 * @access protected
	 * @param {MediaStream} oldStream
	 * @param {MediaStream} newStream
	 */
	renegotiate(oldStream, newStream) {
		Log.d(&apos;PeerConnection~renegotiate&apos;);
		if((Object.getOwnPropertyDescriptor(RTCPeerConnection.prototype, &apos;getSenders&apos;))
			&amp;&amp; (&apos;RTCRtpSender&apos; in window)
			&amp;&amp; Object.getOwnPropertyDescriptor(RTCRtpSender.prototype, &apos;replaceTrack&apos;)){

			// mozRTCPeerConnection implementation
			this.pc.getSenders().forEach(sender =&gt; {
				let newTracks;
				switch (sender.track.kind) {
					case &apos;audio&apos;:
						newTracks = newStream.getAudioTracks();
						break;
					case &apos;video&apos;:
						newTracks = newStream.getVideoTracks();
						break;
					default:
						newTracks = [];
				}
				if(newTracks.length) {
					sender.replaceTrack(newTracks[0]);
				}
			});
			this._sendOffer()
				.catch(e =&gt; {Log.d(&apos;PeerConnection~renegotiate&apos;, e);});
		} else {
			this._alterStream(oldStream, &apos;remove&apos;);
			this._alterStream(newStream, &apos;add&apos;);
		}
	}

	/**
	 * Close the PeerConnection and stop listening to SDP messages
	 * @access protected
	 */
	close() {
		if(this._status === OPENED) {
			this._status = CLOSING;
			// Stop display
			if (this.node) {
				this.node.stop &amp;&amp; this.node.stop();
				this.node.srcObject = null;
				this.container.removeChild(this.node);
				this.node = null;
			}
			// Stop listening to remote ICE candidates
			this._remoteICECandidates(false);
			// Stop listening to SDP messages
			DataSync.off(`${this._remotePath}/sdp`, &apos;value&apos;);
			// Remove data
			DataSync.remove(this._localPath);
			// Close PeerConnection
			if (this.pc &amp;&amp; this.pc.signalingState !== &apos;closed&apos;) {
				this.pc.onsignalingstatechange = () =&gt; {
					if(this.pc.signalingState !== &apos;closed&apos;) {
						this._status = CLOSED;
					}
				};
				this.pc.close();
			} else {
				this._status = CLOSED;
			}
		}
	}

	/**
	 * Edits the SDP to set the preferred audio/video codec
	 * @access private
	 * @param {RTCSessionDescription} description The description retrieved by createOffer/createAnswer
	 * @returns {RTCSessionDescription|{sdp: string, type: string}}
	 */
	_setPreferredCodecs(description) {
		if(cache.config.preferredVideoCodec || cache.config.preferredAudioCodec) {
			Log.d(&apos;PeerConnection~_setPreferredCodecs&apos;, {description, config: cache.config});
			const sdpLines = description.sdp.split(/\r?\n/);
			const medias = {audio: [], video: []};
			let current = null;
			// Parse SDP
			sdpLines.forEach((sdpLine, i) =&gt; {
				if(/^m=/.test(sdpLine)) {
					const d = /^m=(\w+)\s[0-9\/]+\s[A-Za-z0-9\/]+\s([0-9\s]+)/.exec(sdpLine);
					current = {
						fmt: d[2].split(/\s/),
						index: i,
						codecs: []
					};
					medias[d[1]].push(current);
				} else if(current &amp;&amp; /^a=rtpmap:/.test(sdpLine)) {
					const c = /^a=rtpmap:(\d+)\s([a-zA-Z0-9\-\/]+)/.exec(sdpLine);
					if(c) {
						current.codecs.push({
							id: c[1],
							name: c[2],
							index: i
						});
					}
				}
			});
			Log.d(&apos;PeerConnection~_setPreferredCodecs&apos;, medias);
			let update = false;
			const prefer = (mediaList, preferedCodec) =&gt; {
				mediaList.forEach(media =&gt; {
					const selected = media.codecs.find(codec =&gt; preferedCodec.test(codec.name));
					if(selected) {
						const fmt = [selected.id].concat(media.fmt.filter(ids =&gt; ids !== selected.id));
						sdpLines[media.index] = sdpLines[media.index].replace(media.fmt.join(&apos; &apos;), fmt.join(&apos; &apos;));
						update = true;
					}
				});
			};
			if(cache.config.preferredVideoCodec) {
				prefer(medias.video, cache.config.preferredVideoCodec);
			}
			if(cache.config.preferredAudioCodec) {
				prefer(medias.audio, cache.config.preferredAudioCodec);
			}
			if(update) {
				Log.d(&apos;PeerConnection~_setPreferredCodecs&apos;, sdpLines.join(&apos;\r\n&apos;));
				return {
					sdp: sdpLines.join(&apos;\r\n&apos;),
					type: description.type
				};
			}
		}
		return description;
	}
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
