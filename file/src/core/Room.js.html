<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/core/Room.js | Reach API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/webcom-components/reach" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Reach.js~Reach.html">Reach</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Config.js~Config.html">Config</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Invite.js~Invite.html">Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Message.js~Message.html">Message</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Participant.js~Participant.html">Participant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Room.js~Room.html">Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/User.js~User.html">User</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core/stream</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Local.js~Local.html">Local</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/stream/Remote.js~Remote.html">Remote</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core/util</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/util/Media.js~Media.html">Media</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core/webrtc</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/webrtc/PeerConnection.js~PeerConnection.html">PeerConnection</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">definitions</div><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Browser">Browser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/audio">Codec/audio</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec/video">Codec/video</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Invite">Events/Invite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Reach">Events/Reach</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Room">Events/Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Events/Stream">Events/Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ICEServer">ICEServer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StreamTypes">StreamTypes</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">external/datasync</div><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/Webcom.html">Webcom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://datasync.orange.com/doc/api.Query.html#~cancelCallback">Webcom/api.Query~cancelCallback</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">external/dom</div><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element">Element</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">external/webrtc</div><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://w3c.github.io/mediacapture-main/#idl-def-MediaDeviceInfo">MediaDeviceInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#stream-api">MediaStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStreamConstraints">MediaStreamConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints">MediaTrackConstraints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#interface-definition">RTCPeerConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcrtpsender-interface">RTCRtpSender</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://w3c.github.io/webrtc-pc/#rtcsessiondescription-class">RTCSessionDescription</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/core/Room.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {NONE, OPENED, CLOSED, CONNECTED, NOT_CONNECTED, WAS_CONNECTED, OWNER} from &apos;./util/constants&apos;;
import * as DataSync from &apos;./util/DataSync&apos;;
import cache from &apos;./util/cache&apos;;
import Participant from &apos;./Participant&apos;;
import Message from &apos;./Message&apos;;
import Local from &apos;./stream/Local&apos;;
import Invite from &apos;./Invite&apos;;
import * as Events from &apos;../definitions/Events&apos;;
import * as Log from &apos;./util/Log&apos;;
import {REJECTED, CANCELED} from &apos;./util/constants&apos;;

const _joinRoom = (room, role) =&gt; {
	const participant = {
		status: CONNECTED,
		_joined: DataSync.ts()
	};
	if(role) {
		participant.role = role;
	}
	Log.w(&apos;Room#join&apos;, [participant, `_/rooms/${room.uid}/participants/${cache.user.uid}`]);
	return DataSync
		.update(`_/rooms/${room.uid}/participants/${cache.user.uid}`, participant)
		.then(() =&gt; {
			DataSync
				.onDisconnect(`_/rooms/${room.uid}/participants/${cache.user.uid}/status`)
				.set(WAS_CONNECTED);
			return room;
		});
};

/**
 * Room information
 * @access public
 */
export default class Room {
	/**
	 * Create a room
	 * @param {Webcom/api.DataSnapshot|Object} snapData The data snapshot
	 * @access protected
	 */
	constructor(snapData) {
		let values = snapData;
		if(snapData &amp;&amp; snapData.val &amp;&amp; typeof snapData.val === &apos;function&apos;){
			values = Object.assign({}, snapData.val(), {uid: snapData.name()});
		}
		/**
		 * The room unique id
		 * @type {string}
		 */
		this.uid = values.uid;
		/**
		 * The room name
		 * @type {string}
		 */
		this.name = values.name;
		/**
		 * The room owner uid
		 * @type {string}
		 */
		this.owner = values.owner;
		/**
		 * The room status:
		 * - OPENED
		 * - CLOSED
		 * @type {string}
		 */
		this.status = values.status;

		/**
		 * Indicates that the room is public so all users can join
		 * @type {boolean}
		 */
		this._public = !!values._public;

		/**
		 * Additional room informations
		 * @type {Object}
		 */
		this.extra = values.extra;

		/**
		 * List of declared callbacks
		 * @type {Object}
		 */
		this._callbacks = {};
	}

	/**
	 * Get the list of participants.
	 * This will only work if the user is either a participant or the owner of the room.
	 * @returns {Promise&lt;Participant[], Error&gt;}
	 */
	participants() {
		return DataSync.list(`_/rooms/${this.uid}/participants`, Participant, this.uid);
	}

	/**
	 * Get the list of messages.
	 * This will only work if the user is either a participant or the owner of the room.
	 * @return {Promise&lt;Message[], Error&gt;}
	 */
	messages() {
		return DataSync.list(`_/rooms/${this.uid}/messages`, Message, this.uid);
	}

	/**
	 * Get the list of streams
	 * @returns {Promise}
	 * @access private
	 */
	_streams(localStreams) {
		if(!cache.user) {
			return Promise.reject(new Error(&apos;Only an authenticated user can list a Room\&apos;s streams.&apos;));
		}
		return DataSync.get(`_/rooms/${this.uid}/streams`)
			.then(snapData =&gt; {
				const values = snapData.val();
				Log.d(&apos;Rooms~_streams&apos;, values);
				if(values) {
					return Object.keys(values).map(key =&gt; Object.assign({uid: key, roomId: this.uid}, values[key]));
				}
				return [];
			})
			.then(streams =&gt; streams.filter(stream =&gt; {
				return localStreams === (stream.device === cache.device &amp;&amp; stream.from === cache.user.uid);
			}))
			.then(streams =&gt; streams.map(cache.streams[`get${localStreams ? &apos;Shared&apos; : &apos;Remote&apos;}`].bind(cache.streams)))
			.then(streams =&gt; streams.filter(stream =&gt; stream !== null));
	}

	/**
	 * Get the list of locally published streams. The streams published with another device won&apos;t be visible here
	 * This will only work if the user is either a participant or the owner of the room.
	 * @return {Promise&lt;Local[], Error&gt;}
	 */
	localStreams() {
		return this._streams(true)
			.catch(Log.r(&apos;Room~localStreams&apos;));
	}

	/**
	 * Get the list of remotely published streams.
	 * This will only work if the user is either a participant or the owner of the room.
	 * @return {Promise&lt;Remote[], Error&gt;}
	 */
	remoteStreams() {
		return this._streams(false)
			.catch(Log.r(&apos;Room~remoteStreams&apos;));
	}

	/**
	 * Invite users to the room. this will only work if the current User is the owner or a moderator of this Room.
	 * This will create the invitation and add the user to the participants list.
	 * @param {User[]} users the users to invite
	 * @param {string} [role=&apos;NONE&apos;] the role of the invitee
	 * @param {string} [message] a message to add to the invite
	 * @return {Promise&lt;{room: Room, invites: Invite[]}, Error&gt;}
	 */
	invite(users, role = NONE, message) {
		const
			_path = user =&gt; `_/rooms/${this.uid}/participants/${user.uid}`,
			_data = {
				status: NOT_CONNECTED,
				role: role || NONE
			};
		// Add users as participant so they can join the room
		return Promise.all(users.map(user =&gt; DataSync.set(_path(user), _data)))
			// Send invites
			.then(() =&gt; Promise.all(users.map(user =&gt; Invite.send(user, this, message))))
			.then(invites =&gt; {
				const removeParticipant = invite =&gt; DataSync.remove(`_/rooms/${invite.room}/participants/${invite.to}`);
				invites.forEach(invite =&gt; {
					invite.on(REJECTED, removeParticipant);
					invite.on(CANCELED, removeParticipant);
				});
				return {room: this, invites};
			})
			.catch(e =&gt; {
				Log.e(&apos;Room~invite&apos;, e);
				users.forEach(user =&gt; DataSync.remove(`_/rooms/${this.uid}/participants/${user.uid}`));
				return Promise.reject(e);
			});
	}

	/**
	 * Register a callback for a specific event
	 * @param {string} event The event name ({@link Events/Room}):
	 * - PARTICIPANT_ADDED: a participant is added to the room
	 * - PARTICIPANT_CHANGED: a participant changes his status (join)
	 * - PARTICIPANT_REMOVED: a participant leave the room
	 * - MESSAGE_ADDED: new instant message
	 * - MESSAGE_CHANGED: an existing message has been modified (moderation)
	 * - MESSAGE_REMOVED: a message has been removed (moderation)
	 * - STREAM_PUBLISHED: a participant published a new Stream
	 * - STREAM_CHANGED: a participant changes his published Stream (moderation, type, mute...)
	 * - STREAM_UNPUBLISHED: a participant stops the publication of his Stream
	 * @param {function} callback The callback for the event, the arguments depends on the type of event:
	 * - PARTICIPANT_* : callback({@link Participant} p [, Error e])
	 * - MESSAGE_* : callback({@link Message} m [, Error e])
	 * - STREAM_* : callback({@link Remote} s [, Error e])
	 * @param {Webcom/api.Query~cancelCallback} cancelCallback The error callback for the event, takes an Error as only argument
	 */
	on(event, callback, cancelCallback) {
		const
			path = Events.room.toPath(event)(this),
			obj = Events.room.toClass(event);
		if(path &amp;&amp; obj) {
			const typedCallback = snapData =&gt; {
				if(!/^STREAM_/i.test(event) || !snapData) {
					Log.i(`Room~on(${event})`, snapData ? new obj(snapData) : null);
					callback(snapData ? new obj(snapData) : null);
				} else if(cache.user) {
					const streamData = Object.assign({uid: snapData.name(), roomId: this.uid}, snapData.val());
					if(streamData.from !== cache.user.uid || streamData.device !== cache.device) {
						const remoteStream = cache.streams.getRemote(streamData);
						Log.i(`Room~on(${event})`, remoteStream);
						callback(remoteStream);
					}
				}
			};
			DataSync.on(path, event, typedCallback, cancelCallback);
			if(!this._callbacks[event]) {
				this._callbacks[event] = [];
			}
			this._callbacks[event].push(typedCallback);
		}
	}

	/**
	 * Send an instant message
	 * @param {string} message The message to send
	 * @return {Promise&lt;Message&gt;}
	 */
	sendMessage(message) {
		return Message.send(this, message);
	}

	/**
	 * Publish a local stream
	 * @param {string} type The stream type, see {@link StreamTypes} for possible values
	 * @param {Element} [localStreamContainer] The element the stream is attached to. Can be null if already specified in {@link Config}.
	 * @param {MediaStreamConstraints} [constraints] The stream constraints. If not defined, the constraints defined in {@link Config} will be used.
	 * @returns {Promise&lt;Local, Error&gt;}
	 */
	share(type, localStreamContainer, constraints) {
		Log.i(&apos;Room~share&apos;, {type, localStreamContainer, constraints});
		return Local.share(this.uid, type, localStreamContainer, constraints);
	}

	/**
	 * Join the room. Sets the connected status of the current participant to CONNECTED.
	 * @return {Promise}
	 */
	join() {
		Log.i(&apos;Room~join&apos;, this);
		if(!cache.user) {
			return Promise.reject(new Error(&apos;Only an authenticated user can join a Room.&apos;));
		}
		return _joinRoom(this).catch(Log.r(&apos;Room~join&apos;));
	}

	/**
	 * Leave the room. Sets the connected status of the current participant to WAS_CONNECTED, deletes medias and callbacks, closes WebRTC stacks in use.
	 * @return {Promise}
	 */
	leave() {
		if(!cache.user) {
			return Promise.reject(new Error(&apos;Only an authenticated user can leave a Room.&apos;));
		}
		Log.i(&apos;Room~leave&apos;, this);
		// Cancel onDisconnect
		DataSync.onDisconnect(`_/rooms/${this.uid}/participants/${cache.user.uid}/status`).cancel();

		// Disconnect user&apos;s callbacks
		Object.keys(this._callbacks).forEach(event =&gt; {
			DataSync.off(Events.room.toPath(event)(this), event);
		});
		// Unpublish all local streams
		this.localStreams().then(localStreams =&gt; localStreams.forEach(localStream =&gt; localStream.close()));
		// Unsubscribe all remote streams
		this.remoteStreams().then(remoteStreams =&gt; remoteStreams.forEach(remoteStream =&gt; remoteStream.unSubscribe()));
		// Update status
		return DataSync.set(`_/rooms/${this.uid}/participants/${cache.user.uid}/status`, WAS_CONNECTED)
			.catch(Log.r(&apos;Room~leave&apos;));
	}

	/**
	 * Leaves &amp; close the Room. Only the owner/moderator can close a room.
	 * @return {Promise}
	 */
	close() {
		Log.i(&apos;Room~close&apos;, this);
		return this.leave()
			.then(() =&gt; DataSync.update(`rooms/${this.uid}`, {
				status: CLOSED,
				_closed: DataSync.ts()
			}))
			.then(() =&gt; DataSync.remove(`_/rooms/${this.uid}`))
			.catch(Log.r(&apos;Room~close&apos;));
	}

	/**
	 * Create a room
	 * @access protected
	 * @param {String} [name] The room name
	 * @param {object} [extra=null] Extra informations
	 * @param {boolean} [publicRoom=false] Indicates public room
	 * @returns {Promise&lt;Room, Error&gt;}
	 */
	static create (name, extra = null, publicRoom = false) {
		if(!cache.user) {
			return Promise.reject(new Error(&apos;Only an authenticated user can create a Room.&apos;));
		}

		const
			roomMetaData = {
				owner: cache.user.uid,
				_public: publicRoom,
				name: name || `${cache.user.name}-${Date.now()}`
			},
			roomFullMetaData = Object.assign({
				status: OPENED,
				_created: DataSync.ts(),
				extra
			}, roomMetaData);

		let room = null;
		// Create public room infos
		return DataSync.push(&apos;rooms&apos;, roomFullMetaData)
			// Create private room infos
			.then(roomRef =&gt; {
				room = new Room(Object.assign({uid: roomRef.name()}, roomFullMetaData));
				return DataSync.update(`_/rooms/${room.uid}/meta`, roomMetaData);
			})
			// Join the room
			.then(() =&gt; _joinRoom(room, OWNER))
			.catch(Log.r(&apos;Room#create&apos;));
	}

	/**
	 * Get a {@link Room} from its `uid`
	 * @access protected
	 * @param uid
	 * @returns {Promise.&lt;Room&gt;}
	 */
	static get (uid) {
		return DataSync.get(`rooms/${uid}`)
			.then(snapData =&gt; {
				if(snapData.val()) {
					return new Room(snapData);
				}
			});
	}
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
